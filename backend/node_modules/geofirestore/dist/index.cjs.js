'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var geofirestoreCore = require('geofirestore-core');

class GeoQuery {
    constructor(_query, queryCriteria) {
        this._query = _query;
        if (Object.prototype.toString.call(_query) !== '[object Object]') {
            throw new Error('Query must be an instance of a Firestore Query');
        }
        this._isWeb =
            Object.prototype.toString.call(_query.firestore
                .enablePersistence) === '[object Function]';
        if (queryCriteria) {
            if (typeof queryCriteria.limit === 'number') {
                this._limit = queryCriteria.limit;
            }
            if (queryCriteria.center && typeof queryCriteria.radius === 'number') {
                geofirestoreCore.validateQueryCriteria(queryCriteria);
                this._center = queryCriteria.center;
                this._radius = queryCriteria.radius;
            }
        }
    }
    get native() {
        return this._query;
    }
    get firestore() {
        return new GeoFirestore(this._query.firestore);
    }
    get onSnapshot() {
        return geofirestoreCore.geoQueryOnSnapshot(this._query, this._queryCriteria);
    }
    get(options = { source: 'default' }) {
        return geofirestoreCore.geoQueryGet(this._query, this._queryCriteria, options);
    }
    limit(limit) {
        geofirestoreCore.validateLimit(limit);
        this._limit = limit;
        return new GeoQuery(this._query, this._queryCriteria);
    }
    near(newGeoQueryCriteria) {
        geofirestoreCore.validateQueryCriteria(newGeoQueryCriteria, true);
        this._center = newGeoQueryCriteria.center;
        this._radius = newGeoQueryCriteria.radius;
        return new GeoQuery(this._query, this._queryCriteria);
    }
    where(fieldPath, opStr, value) {
        return new GeoQuery(this._query.where(fieldPath, opStr, value), this._queryCriteria);
    }
    get _queryCriteria() {
        return {
            center: this._center,
            limit: this._limit,
            radius: this._radius,
        };
    }
}

class GeoWriteBatch {
    constructor(_writeBatch, _customKey) {
        this._writeBatch = _writeBatch;
        this._customKey = _customKey;
        if (Object.prototype.toString.call(_writeBatch) !== '[object Object]') {
            throw new Error('WriteBatch must be an instance of a Firestore WriteBatch');
        }
    }
    get native() {
        return this._writeBatch;
    }
    set(documentRef, documentData, options = {}) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        options.customKey = options.customKey || this._customKey;
        this._writeBatch.set(ref, geofirestoreCore.encodeDocumentSet(documentData, options), sanitizeSetOptions(options));
        return this;
    }
    update(documentRef, data, customKey = this._customKey) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._writeBatch.update(ref, geofirestoreCore.encodeDocumentUpdate(data, customKey));
        return this;
    }
    delete(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._writeBatch.delete(ref);
        return this;
    }
    commit() {
        return this._writeBatch.commit();
    }
}

class GeoFirestore {
    constructor(_firestore) {
        this._firestore = _firestore;
        if (Object.prototype.toString.call(_firestore) !== '[object Object]') {
            throw new Error('Firestore must be an instance of Firestore');
        }
    }
    get native() {
        return this._firestore;
    }
    batch(customKey) {
        return new GeoWriteBatch(this._firestore.batch(), customKey);
    }
    collection(collectionPath, customKey) {
        return new GeoCollectionReference(this._firestore.collection(collectionPath), customKey);
    }
    collectionGroup(collectionId) {
        return new GeoQuery(this._firestore.collectionGroup(collectionId));
    }
    doc(documentPath) {
        return new GeoDocumentReference(this._firestore.doc(documentPath));
    }
    runTransaction(updateFunction) {
        const firestore = this._firestore;
        return firestore.runTransaction(updateFunction);
    }
}

function initializeApp(firestore) {
    return new GeoFirestore(firestore);
}
function sanitizeSetOptions(options) {
    const clone = Object.assign({}, options);
    delete clone.customKey;
    return clone;
}

class GeoDocumentSnapshot {
    constructor(_snapshot) {
        this._snapshot = _snapshot;
        if (Object.prototype.toString.call(_snapshot) !== '[object Object]') {
            throw new Error('DocumentSnapshot must be an instance of a Firestore DocumentSnapshot');
        }
        this._isWeb =
            Object.prototype.toString.call(_snapshot.ref.firestore
                .enablePersistence) === '[object Function]';
    }
    get native() {
        return this._snapshot;
    }
    get exists() {
        return this._snapshot.exists;
    }
    get id() {
        return this._snapshot.id;
    }
    get ref() {
        return new GeoDocumentReference(this._snapshot.ref);
    }
    data(options) {
        const documentData = this._isWeb && options
            ? this._snapshot.data(options)
            : this._snapshot.data();
        return documentData;
    }
    get(fieldPath, options) {
        return this._isWeb && options
            ? this._snapshot.get(fieldPath, options)
            : this._snapshot.get(fieldPath);
    }
    isEqual(other) {
        const ref = other instanceof GeoDocumentSnapshot ? other['_snapshot'] : other;
        return this._snapshot.isEqual(ref);
    }
}

class GeoDocumentReference {
    constructor(_document) {
        this._document = _document;
        if (Object.prototype.toString.call(_document) !== '[object Object]') {
            throw new Error('DocumentReference must be an instance of a Firestore DocumentReference');
        }
        this._isWeb =
            Object.prototype.toString.call(_document.firestore
                .enablePersistence) === '[object Function]';
    }
    get native() {
        return this._document;
    }
    get id() {
        return this._document.id;
    }
    get firestore() {
        return new GeoFirestore(this._document.firestore);
    }
    get onSnapshot() {
        return (onNext, onError = () => { }) => {
            const document = this
                ._document;
            return document.onSnapshot(snapshot => onNext(new GeoDocumentSnapshot(snapshot)), error => onError(error));
        };
    }
    get parent() {
        return new GeoCollectionReference(this._document.parent);
    }
    get path() {
        return this._document.path;
    }
    collection(collectionPath) {
        return new GeoCollectionReference(this._document.collection(collectionPath));
    }
    delete() {
        return this._document
            .delete()
            .then(() => null);
    }
    get(options = { source: 'default' }) {
        const get = this._isWeb
            ? this._document.get(options)
            : this._document.get();
        return get.then(snapshot => new GeoDocumentSnapshot(snapshot));
    }
    isEqual(other) {
        const ref = other instanceof GeoDocumentReference ? other['_document'] : other;
        return this._document.isEqual(ref);
    }
    set(documentData, options) {
        return this._document
            .set(geofirestoreCore.encodeDocumentSet(documentData, options), sanitizeSetOptions(options))
            .then(() => null);
    }
    update(data, customKey) {
        return this._document
            .update(geofirestoreCore.encodeDocumentUpdate(data, customKey))
            .then(() => null);
    }
}

class GeoCollectionReference extends GeoQuery {
    constructor(_collection, _customKey) {
        super(_collection);
        this._collection = _collection;
        this._customKey = _customKey;
    }
    get native() {
        return this._collection;
    }
    get id() {
        return this._collection.id;
    }
    get parent() {
        return this._collection.parent
            ? new GeoDocumentReference(this._collection.parent)
            : null;
    }
    get path() {
        return this._collection.path;
    }
    add(documentData, customKey = this._customKey) {
        return this._collection
            .add(geofirestoreCore.encodeDocumentAdd(documentData, customKey))
            .then(doc => new GeoDocumentReference(doc));
    }
    doc(documentPath) {
        return documentPath
            ? new GeoDocumentReference(this._collection.doc(documentPath))
            : new GeoDocumentReference(this._collection.doc());
    }
}

class GeoTransaction {
    constructor(_transaction, _customKey) {
        this._transaction = _transaction;
        this._customKey = _customKey;
        if (Object.prototype.toString.call(_transaction) !== '[object Object]') {
            throw new Error('Transaction must be an instance of a Firestore Transaction');
        }
    }
    get native() {
        return this._transaction;
    }
    delete(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._transaction.delete(ref);
        return this;
    }
    get(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        return this._transaction
            .get(ref)
            .then((snpashot) => new GeoDocumentSnapshot(snpashot));
    }
    set(documentRef, documentData, options = {}) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        options.customKey = options.customKey || this._customKey;
        this._transaction.set(ref, geofirestoreCore.encodeDocumentSet(documentData, options), sanitizeSetOptions(options));
        return this;
    }
    update(documentRef, data, customKey = this._customKey) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._transaction.update(ref, geofirestoreCore.encodeDocumentUpdate(data, customKey));
        return this;
    }
}

exports.GeoCollectionReference = GeoCollectionReference;
exports.GeoDocumentReference = GeoDocumentReference;
exports.GeoDocumentSnapshot = GeoDocumentSnapshot;
exports.GeoFirestore = GeoFirestore;
exports.GeoQuery = GeoQuery;
exports.GeoTransaction = GeoTransaction;
exports.GeoWriteBatch = GeoWriteBatch;
exports.initializeApp = initializeApp;
